\chapter{Graphical User Interface}

\section{Introduction}
\subsection{Continuation of previous work}
During the \preproject a simple way of interacting with the system from a phone over \gls{ssh} through an app called JuiceSSH was tested as described in Section 6.5.2 of the \preproject.
Using JuiceSSh to control the \sr was pursued further, and several usefull snippets were saved in the app to make it easy to execute the necessary commands to start and stop recording.
However it was soon realized that it was not a satisfying solution as it was difficult to verify that the camera was recording what they were supposed to.
Multiple different programs also has to be executed and monitored simultaneously, which is challenging in JuiceSSH.


\subsection{Motivation for web based GUI}
As the \sr is recording video, it was natural to look for a \gls{gui} framework where the video could be displayed.
Integrating a monitor and input devices into the \sr and create a \gls{qt} application was considered but quickly dismissed as it would require a lot of work and would make the \sr less portable.
A web based \gls{gui} seemed better as it could be accessed from an external mobile phone, as the \sr is equipped with a WiFi module and can connect to a mobile hotspot as discussed in Section 6.5
of the \preproject.
The \gls{dash} framework was chosen as it is based on \py and has a lot of useful components for creating web based \glspl{gui}.

In a more general context the need for a good way to interact visually with programs and visualize data from a remote computers was identified.
The development on the \jx has been done over \gls{ssh}, making regular visualization of data, with tools like \texttt{matplotlib}, cumbersome.
The data gathered from the \sr is intended to be used for training and inference of \gls{ai} models during my Ph.D. and a headless workstation has been aquired for this purpose, making the \gls{gui} framework relevant for future work.

\subsection{Alternatives}
Initially the I wanted to use this as an opertunity to learn a \gls{js} framework like React, Vue or Svelte.
However, with very little personal experience using \gls{js} it appeared too ambitious to learn a new framework in a new language.
I decided to go for \gls{dash} insetead, a \py framework for building web applications with interactive data visualizations and analytical capabilities \cite{plotlyPlotlyLowCodeData}.
As it is based on \py, the learning curve would be less steep.

\subsection{Downsides}
The main downside of using \gls{dash} is that it is not designed for real time applications and lacks native support for \glsps{websocket}.
On their website they only propose using an interval component to poll the server for updates at regular intervals  \cite{plotlyLiveUpdatesDasha}.
This works, but if data should be sent from the server as soon as it becomes available, like when you are recording video, it is not the best solution.

Another small downside is that \gls{dash} is built on top of Flask, a thread based server framework which is slower than newer asynchronous alternatives.

