
\section{Debugging and Profiling}

\subsection{Throughput and Latency}
In sequential programming measuring the performance of a program can be done through measuring its execution time.
This can be acheived by recording the time when the program starts and when it finishes, and calculating the difference.
The througput then becomes the

The impact of future optimizations can then be measured by comparing the execution times before and after the optimizations are applied.
As the number of tasks that can be solved in a given time is

However, in concurrent processing, execution times of individual instructions may overlap, making it challenging to calculate the execution time of the individual instructions \cite[21]{volkovLatencyHiding2016}.
The same type for time measurements can still be performed, but i

Instead, metrics such as latency, throughput, and concurrency can be used to characterize the process.

For example, latency is the average time between the start and end times of individual items, while throughput is the number of items processed within a given time interval divided by the duration of the interval.
Concurrency is the number of items processed simultaneously and can be measured at different moments in time or as an average over a particular interval.

\subsection{Creating Minimal Testing Example}
Wen debugging and profiling real-time applications it is often b

Beyond this the use of coroutines offers more control over the execution of the program, at the cost of requiring more thought to be put into the design of the program to avoid blocking the event loop.


\begin{listing}[H]
    \begin{minted}{python}
        def sleep_1sec(): time.sleep(1)
        async def sleep_1sec_async(): await asyncio.sleep(1)

        async def test_asyncio():
            await asyncio.gather(*[sleep_1sec_async() for _ in range(N)])

        def test_thread_pool():
            with ThreadPoolExecutor(max_workers=10000) as ex:
                futures = [ex.submit(sleep_1sec) for _ in range(N)]

        async def test_thread_pool_async():
            loop = asyncio.get_event_loop()
            with ThreadPoolExecutor(max_workers=10000) as ex:
                asyncio.gather(*[loop.run_in_executor(ex, sleep_1sec) for _ in range(10000)])

        def test_threads():
            threads = [threading.Thread(target=do_nothing) for _ in range(10000)]
            [thread.start() for thread in threads]
            [thread.join() for thread in threads]
    \end{minted}
    \caption{Code used to compatre asyncio and threads.}
    \label{listing:concurrency_test}
\end{listing}
\begin{listing}[H]
    \begin{minted}{bash}
        >>> test_asyncio took 1.373797 seconds to complete.
        >>> test_thread_pool took 4.091199 seconds to complete.
        >>> test_thread_pool_async took 4.391777 seconds to complete.
        >>> test_threads took 5.373108 seconds to complete.
    \end{minted}
    \caption{Results when running the code in Listing  \ref{listing:concurrency_test} on the \jx}
\end{listing}


% \begin{listing}[H]
%     \begin{minted}{python}
%         import asyncio, threading, time

%         def do_nothing(): pass
%         async def do_nothing_async(): pass

%         async def test_asyncio():
%             start_time = time.perf_counter()
%             await asyncio.gather(*[do_nothing_async() for _ in range(10000)])
%             end_time = time.perf_counter()
%             print(f"Asyncio took {end_time - start_time:.6f} seconds to complete.")

%         def test_threads():
%             threads = [threading.Thread(target=do_nothing) for _ in range(10000)]
%             start_time = time.perf_counter()
%             for thread in threads:
%                 thread.start()
%             for thread in threads:
%                 thread.join()
%             end_time = time.perf_counter()
%             print(f"Threads took {end_time - start_time:.6f} seconds to complete.")

%         if __name__ == "__main__":
%             asyncio.run(test_asyncio())
%             test_threads()
%     \end{minted}
%     \begin{minted}{bash}
%         >>> Asyncio took 0.311703 seconds to complete.
%         >>> Threads took 11.898036 seconds to complete.
%     \end{minted}
%     \caption{Comparison of asyncio and threads running on INTEL i7-11800H @ 2.30GHz.}
% \end{listing}