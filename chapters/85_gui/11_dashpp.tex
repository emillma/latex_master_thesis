\subsection{Replacing Flask backend with Quart}
The first step in the development of the \guif was to replace the Flask backend with \gls{quart}.
As the comperaison in Listing \ref{listing:concurrency_test} shows, \gls{asyncio} baseded code has significantly less overhead than asynchronous code based threads in \py.


Snehil Vijay has created a fork of \gls{dash}, called \gls{async-dash}, that replaces the Flask backend with \gls{quart} \cite{vijaySnehilvjAsyncdash2023}.
Another project aimed at making \gls{dash} run \gls{quart} called \code{dash_deviced} was also tested, but was not as easy to use as the fork by Snehil Vijay, and did not have any acivity for the last  \cite{legrandCodeFrequencyRichlegrand}.

\todo \gls{async-dash} does not handle the running parameter.

\subsection{Adding support for websockets}
WebSockets is technology that enables two-way communication between a user's browser and a server.
\cite{farhutsWebSocketsBeginnersPart2019}.
Unlike traditional HTTP, which requires the browser to constantly request information from the server, WebSockets allow for a persistent \gls{tcp} connection as visualized in Figure \ref{fig:websockets_vs_http}\cite{tingUnderstandingWebSocketsIts2020}.
This means that the server can send updates to the browser in real-time without the need for continuous requests.
\glspl{ws} also offer an easy way to communicate between processes similar to \gls{tcp} sockets, but with a simpler interface \cite{kanakaAnswerDifferencesTCP2013}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/gui/http_vs_ws.png}
    \caption{WebSockets Vs HTTP \cite{wallarmWebSocketVsHTTP}}
    \label{fig:websockets_vs_http}
\end{figure}

A significant motivation for using \gls{quart} as backend is that it supports \glspl{ws} nativly \cite{quartUsingWebsocketsQuart}.
\gls{dash} does not support \glspl{ws} out of the box, but this feature can be added through the \gls{dashextensions} library \cite{eriksenDashExtensionsWebSocket}.
Using \gls{ws} for real time updates in \gls{dash} is both a lot easier and a lot faster than the recomended way, which is to poll the server for updates at regular intervals \cite{plotlyLiveUpdatesDash}.
To make it easier to work with \gls{ws} in \gls{dash} a small publisher-subscriber framework was developed.
This is used among other things to update the images in the \srgui, in real time, from the topics \code{"image_left"} and \code{"image_right"} which the \gls{pipeline} publishes to.

\subsection{Publish-subscribe framework}
\code{ws://localhost:8088/pubsub?pub=topic1&sub=topic0}

\subsection{Multi-page apps}
Dash supports multi-page apps, making it possible to create a web application with multiple pages that the user can navigate between \cite{plotlyMultiPageAppsURL}.
The primary intended use for this was to have separate pages on the \srgui.
One for cameara control and visualization, one for starting and monitoring recordings and one for general monitoring of the system.
A developer named Ann Marie Ward has created a set of examples on how to work with multi-page apps that was used as a starting point \cite{wardExamplesMultipageApps03Jul22}.

One major issue was that \gls{async-dash} did not work with multi-page apps.
Fortunately there is an open pull-request that fixes this issue \cite{lekAddFlaskRequest2022}.