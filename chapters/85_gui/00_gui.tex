\chapter{Graphical User Interface}


\section{Motivation}
A \gls{gui} framework has been developed during the master thesis.
There were two main motivations behind this.

In order to operate a camera system in real time it is pretty usefull to be able to see what the camera sees.
During the \preproject a simple way of interacting with the system from a phone over \gls{ssh} through an app called juiceSSH was tested \cite[32]{martensPortableSensorRig2022}.
This app was tested more in the beginning of the master thesis, and several usefull snippets were saved in the app.
Although the text interface was sufficient to start and stop the recording and verify that images were saved, the lack of a graphical interface made it difficult to verify that the camera was recording what it was supposed to.
Thus a \gls{gui} is needed.

In a more general context a need for an efficient way to interact with programs and visualize data on remote computers was identified.
The \jx has been the current platform for the master thesis, but during future work other remote computers will be used.
A powerful workstation with a \todo was aquired last fall to be used for training and inference of \gls{ai} models during future Ph.D. work.
The workstation is headless, that is it has no monitor, keyboard or mouse, as we are a couple of people that will be using it.

\subsection{Specifications}
There are a lot of different options to choose from when it comes to \gls{gui} frameworks.
But the following requirements were identified:
\begin{itemize}
    \item Access from all devices including smartphone
    \item Easy to develop
    \item Capable of real time visualization
    \item Reasonably efficient
    \item Easily customizable
\end{itemize}
From the forst requirement it was clear that the solution would be web based as this it is the easiest way to make a \gls{gui} that is accessible from different types of devices.
Using a \gls{js} framework like React, Vue or Svelte would probably have been a good choice, but with very little personal experience using \gls{js} it appeared too ambitious to learn a new framework in a new language.
\dash was chosen as it is based on \py, making the learning curve less steep.


\dash is not designed for real time applications and lacks native support for \glsps{websocket}.
Fortunately a group of people have developed a package called \texttt{dash-extensions} that adds support for \glsps{websocket} to \dash \cite{eriksenDashExtensions}.
To improve performance the thread baced backend of \dash, Flask, was replaced with asynchronous Quart.

\subsection{Replacing Flask backend with Quart}

\subsection{Adding support for websockets}

\subsection{Websockets through Quart and Dash-Extentions}
\cite{plotlyLiveUpdatesDash}

\subsection{Client side callbacks and custom Javascript handler}
Using \gls{dash}`s default python callbacks have a considerable overhead as they are executed on the server, requiring data to be sent back and forth \cite{plotlyPartBasicCallbacks}.
However, as the primary motivation for adopting \gls{dash} was to make the development process fast, not making optimal applications, this is not a major issue.
Still, from som particular callabacs used for real time visualization it is preferable to have the callbacks executed on the client side.

\gls{dash} is capable of definig client side callbacks in \gls{js} \cite{plotlyClientsideCallbacksDash}.
They can be served from separate \gls{js} files or be inlined as strings in \py and served using the \code{clientside_callback} method.
While proper \gls{js} files are preferable for anything larger than a few lines, as proper syntax highlighting and auto completion is available during development, inlining the \gls{js} code as strings in \py is a practical for minimal callbacks as they can be defined next to the involved components.
A callback that moved data from one location to another or alters the state of a component are examples of minimal callbacks.

The syntax requiered to use \code{clientside_callback} is totally different from the syntax used for regular callbacks.
A custom wrapper was created to
The \gls{js} code can be written in the docstring of the corresponding \py function, making the syntax of defining regular and client side callbacks very similar.

\begin{listing}[H]
    \begin{minted}{python}
        # default server side callback
        @app.callback(
            Output("local_name-text","children"),
            Input("local_name-button", "n_clicks"),
        )
        def update_image(clicks):
            return int(clicks) + 1

        # default cliend side callback
        app.clientside_callback(
            """
            update_image(clicks) {
                return parseInt(clicks) + 1;
            }
            """,
            Output("local_name-text", "children"),
            Input("local_name-button", "n_clicks"),
        )

        # mew server side callback
        @cbm.callback(idp.text.children.as_output())
        async def update_image(clicks: int = idp.button.n_clicks.as_input()):
            return clicks + 1

        # new client side callback
        @cbm.js_callback(idp.text.children.as_output())
        async def update_image(clicks: int = idp.button.as_input("n_clicks")):
            """
            return parseInt(clicks) + 1;
            """
    \end{minted}
    \caption{Example code showing benefit of \gls{cbm} and \gls{idp}.}
    \label{lst:cbm_idp_example}
\end{listing}





\subsection{Pages}
